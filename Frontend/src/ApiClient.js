/*
 * YouChess API - auto-generated by Swagger Codegen v3.0.63
 * Version: 1.0.0-oas3
 * Contact: nievange@ece.auth.gr
 * Do not edit manually.
 */

import superagent from "superagent";

/**
 * API client for handling server communications and parameter handling.
 * Usage is internal; public API provided by *Api and model classes.
 */
export default class ApiClient {
    constructor() {
        /** Base API URL */
        this.basePath = 'https://virtserver.swaggerhub.com/TSAISIDOROS/SySkaki/1.0.0'.replace(/\/+$/, '');

        /** Authentication methods for API calls */
        this.authentications = {};

        /** Default HTTP headers */
        this.defaultHeaders = {};

        /** Default HTTP timeout (ms) */
        this.timeout = 60000;

        /** Prevent browser caching for GET requests */
        this.cache = true;

        /** Enable cookies in server responses */
        this.enableCookies = false;

        if (typeof window === 'undefined') this.agent = new superagent.agent();
        this.requestAgent = null;
    }

    /** Convert parameter to string */
    paramToString(param) {
        return param == null ? '' : param instanceof Date ? param.toJSON() : param.toString();
    }

    /** Build full URL by appending path to base URL and replacing placeholders */
    buildUrl(path, pathParams) {
        path = path.startsWith('/') ? path : '/' + path;
        return this.basePath + path.replace(/\{([\w-]+)\}/g, (_, key) =>
            encodeURIComponent(pathParams?.[key] ?? `{${key}}`)
        );
    }

    /** Check if content type is JSON */
    isJsonMime(contentType) {
        return Boolean(contentType?.match(/^application\/json(;.*)?$/i));
    }

    /** Prefer JSON content type, fallback to the first available */
    jsonPreferredMime(contentTypes) {
        return contentTypes.find(this.isJsonMime.bind(this)) || contentTypes[0];
    }

    /** Check if parameter is file-like */
    isFileParam(param) {
        try {
            const fs = require('fs');
            if (fs?.ReadStream && param instanceof fs.ReadStream) return true;
        } catch {}
        return [Buffer, Blob, File].some(type => typeof type === 'function' && param instanceof type);
    }

    /** Normalize parameter values (remove nulls, convert to strings) */
    normalizeParams(params) {
        const newParams = {};
        for (const [key, value] of Object.entries(params || {})) {
            newParams[key] = this.isFileParam(value) || Array.isArray(value) ? value : this.paramToString(value);
        }
        return newParams;
    }

    /** Collection format strategies */
    static CollectionFormatEnum = {
        CSV: ',',
        SSV: ' ',
        TSV: '\t',
        PIPES: '|',
        MULTI: 'multi'
    };

    /** Build string from array parameter using specified format */
    buildCollectionParam(param, format) {
        if (param == null) return null;
        const joiners = { csv: ',', ssv: ' ', tsv: '\t', pipes: '|', multi: null };
        return format === 'multi' ? param.map(this.paramToString) : param.map(this.paramToString).join(joiners[format]);
    }

    /** Apply authentication headers to request */
    applyAuthToRequest(request, authNames) {
        authNames.forEach(authName => {
            const auth = this.authentications[authName];
            if (auth?.type === 'basic' && (auth.username || auth.password)) {
                request.auth(auth.username || '', auth.password || '');
            } else if (auth?.type === 'apiKey' && auth.apiKey) {
                const data = { [auth.name]: auth.apiKeyPrefix ? `${auth.apiKeyPrefix} ${auth.apiKey}` : auth.apiKey };
                auth.in === 'header' ? request.set(data) : request.query(data);
            } else if (auth?.type === 'oauth2' && auth.accessToken) {
                request.set({ 'Authorization': `Bearer ${auth.accessToken}` });
            }
        });
    }

    /** Deserialize response to specified type */
    deserialize(response, returnType) {
        if (!response || !returnType || response.status === 204) return null;
        const data = response.body || response.text;
        return ApiClient.convertToType(data, returnType);
    }

        // Sends an API request
        callApi(path, httpMethod, pathParams, queryParams, headerParams, formParams, bodyParam, authNames, contentTypes, accepts, returnType, callback) {
            const url = this.buildUrl(path, pathParams);
            const request = superagent(httpMethod, url);
    
            this.applyAuthToRequest(request, authNames);
            if (httpMethod.toUpperCase() === 'GET' && !this.cache) queryParams['_'] = Date.now();
            request.query(this.normalizeParams(queryParams)).set(this.defaultHeaders).set(this.normalizeParams(headerParams));
            if (this.requestAgent) request.agent(this.requestAgent);
            request.timeout(this.timeout);
    
            const contentType = this.jsonPreferredMime(contentTypes);
            if (contentType && contentType !== 'multipart/form-data') request.type(contentType);
            else if (!request.header['Content-Type']) request.type('application/json');
    
            if (contentType === 'application/x-www-form-urlencoded') {
                request.send(new URLSearchParams(this.normalizeParams(formParams)));
            } else if (contentType === 'multipart/form-data') {
                const _formParams = this.normalizeParams(formParams);
                for (const key in _formParams) {
                    _formParams[key] instanceof Buffer ? request.attach(key, _formParams[key]) : request.field(key, _formParams[key]);
                }
            } else if (bodyParam) request.send(bodyParam);
    
            const accept = this.jsonPreferredMime(accepts);
            if (accept) request.accept(accept);
            if (returnType === 'Blob') request.responseType('blob');
            if (returnType === 'String') request.responseType('string');
    
            if (this.enableCookies) {
                if (typeof window === 'undefined') this.agent.attachCookies(request);
                else request.withCredentials();
            }
    
            request.end((error, response) => {
                if (callback) {
                    let data = null;
                    if (!error) {
                        try {
                            data = this.deserialize(response, returnType);
                            if (this.enableCookies && typeof window === 'undefined') this.agent.saveCookies(response);
                        } catch (err) { error = err; }
                    }
                    callback(error, data, response);
                }
            });
    
            return request;
        }
    
        static parseDate(str) {
            return new Date(str);
        }
    
        // Converts data to the specified type
        static convertToType(data, type) {
            if (!data) return data;
            switch (type) {
                case 'Boolean': return Boolean(data);
                case 'Integer': return parseInt(data, 10);
                case 'Number': return parseFloat(data);
                case 'String': return String(data);
                case 'Date': return ApiClient.parseDate(String(data));
                case 'Blob': return data;
                default:
                    if (type === Object) return data;
                    if (typeof type === 'function') return type.constructFromObject(data);
                    if (Array.isArray(type)) return data.map(item => ApiClient.convertToType(item, type[0]));
                    if (typeof type === 'object') {
                        const [keyType, valueType] = Object.entries(type)[0];
                        return Object.fromEntries(Object.entries(data).map(([k, v]) => [ApiClient.convertToType(k, keyType), ApiClient.convertToType(v, valueType)]));
                    }
                    return data;
            }
        }
    
        // Constructs an object or array from REST data
        static constructFromObject(data, obj, itemType) {
            if (Array.isArray(data)) data.forEach((item, i) => obj[i] = ApiClient.convertToType(item, itemType));
            else Object.keys(data).forEach(key => obj[key] = ApiClient.convertToType(data[key], itemType));
        }
    }
    
    ApiClient.instance = new ApiClient();